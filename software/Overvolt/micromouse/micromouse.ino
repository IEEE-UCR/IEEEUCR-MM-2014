#define TELEMETRY 1
const uint32_t led = 13;
  // This is the pin that the LED on the board goes on
const uint32_t bMillisDelay = 100;
  // This is the delay that starting would have in order not to damage the motors.
const uint32_t stopDelay = 30;
  // This is the delay that the micromouse takes when it's stopping to make sure that the motors are working correctly
const uint32_t uDelay = 650;
  // This is the delay for taking u-turns.
const uint32_t tDelay = 350;
const uint32_t stopRead = 85;// how it tells whether the wall is right in front of it or not
const uint32_t forwardSpeed = 100; // default forward speed
const uint32_t turnSpeed = 30; // default turning speed
const uint32_t turnRead = 750; // how the front sensor says a turn is done
const uint32_t turnThresholdL = 190; // how the side sensors say that something is a turn
const uint32_t turnThresholdR = 190;
const uint32_t activeBrakeTime = 170;
const uint32_t activeBrakeSpeed = 15;
const uint32_t activeTurnBrakeTime = 180;
const uint32_t activeTurnBrakeSpeed = 10;
volatile uint32_t lMotorEnc = 0;
volatile uint32_t rMotorEnc = 0;
const uint32_t sensorPinL = A0;
const uint32_t sensorPinR = A2;

unsigned long lLastMillis;  // We use this variable later on for timed backing up...
#define FORWARD 0 // Define forward so that the operator doesn't get confused about which direction the mouse is headed in.
#define BACKWARD 1 // Same with backward
#include "mctrl.h" // include the class description of the mouse
#include "encodr.h"
#include "fill.h"
enum eStates { eForward = 1, eTurnU = 2, eTurnL = 3, eTurnR = 4 }; // Enumerate the states that the upper finite-state machine can be in
void w8 (const uint32_t w8Time) {
  lLastMillis = millis();
  do {  } while ((millis() - lLastMillis) <= w8Time );
}
void setup() {
  for (uint32_t i = 5; i <= 10; i++) { // use a for loop to init. the pins of the microcontroller
    pinMode (i, OUTPUT); 
  }
  pinMode (led, OUTPUT); // init the LED pin correctly
  pinMode (A0, INPUT);  // have the sensors 
  pinMode (A1, INPUT);
  pinMode (A2, INPUT);
  pinMode (A5, INPUT);
  pinMode (A6, INPUT);
  pinMode (0, OUTPUT);
  pinMode (1, INPUT);
  pinMode (11, INPUT);
  pinMode (12, INPUT);
  attachInterrupt(11, lMotorInc, CHANGE);
  attachInterrupt(12, rMotorInc, CHANGE);
  delay(1000);
  delay(1000);
  delay(1000); // put a delay here so that the mouse won't go springing off immediately after turning on
#if TELEMETRY
  Serial1.begin(9600);
#endif
}
mCtrl faulhaber(forwardSpeed, FORWARD, 7, 8, 9, 10, bMillisDelay, 5.00, 15);
// this syntax is a little confusing.  so I'll break it down.
/*    default motor speed,
      default motor direction,
      L motor control
      R motor control
      L motor PWM
      R motor PWM
      millisecond delay for soft starts and pid
      P value
      I value
      D value
      initial sensor sample size
*/

// These are calculated encoder counts for wall determination. 220 should be the time that it takes to stop the mouse using delays.
encodr enc(265,200,50);

const char _navRandomness[] = {0x9a, 0x81, 0x47, 0x6b, 0x81, 0xbe, 0xb0, 0xf0,
                               0xdc, 0x18, 0x4f, 0x44, 0x9f, 0x62, 0xe8, 0x5a,
                               0xda, 0x6a, 0x7e, 0x08, 0x18, 0x22, 0x6f, 0x95,
                               0x2e, 0xbc, 0xa3, 0x91, 0x15, 0xa1, 0x9c, 0xfd};

boolean Nav_GetRandomBit() {
	static char seed = 0;
	unsigned char this_ = seed & (8-1);
	unsigned char that = _navRandomness[seed/8];
	++seed;
	this_ >>= that;
	this_ &= 0x01;
	
	
	
	return this_;
}

void loop() {
  static eStates eState_t; // use enumerated states
  static int inputL = 0;
  static int inputR = 0;
  static boolean enableHoldBack =  0;
  static boolean t = 0;
  while (t == 0) {
 #if TELEMETRY
    Serial1.println("Calibrate!");
 #endif
    faulhaber.calibrateSensors();
    t++;
  }
  boolean stahpLoop = 0;
  uint32_t sensorL = 0;
  uint32_t sensorR = 0;
  switch (eState_t) {
    case eForward:
      digitalWrite(led, HIGH); // we have the LED on for a nice display
      faulhaber.frictionStop(); // we have it stop by the friction generated by the motors
      faulhaber.switchDirection(FORWARD); // in case things before were set to backward or left or something of that sort, we can set things here to whichever side we want (forward).
      faulhaber.changeSpeed(forwardSpeed);
      faulhaber.speedUp(); // soft speedup to get things rolling
      do {
        sensorL = analogRead(sensorPinL);
        sensorR = analogRead(sensorPinR);
        faulhaber.straightLine(sensorL, sensorR); // use the control algorithm to have things work as they should
        if (enc.cellMark()) {
          Serial1.println("WALL!");
        }
        if (enc.turnOk()) {
          Serial1.println("Turn considered.");
          boolean turnNow = turnNow++;
          if (sensorL > turnThresholdL && turnNow ) {
            stahpLoop = 1;
            enc.forceMark();
            eState_t = eTurnL;
            Serial1.println("TURNING LEFT");
          } else if (sensorR > turnThresholdR && !turnNow ) {
            stahpLoop = 1;
            eState_t = eTurnR;
            enc.forceMark();
            Serial1.println("TURNING RIGHT");
          }
        }
      } while ((analogRead(A1) > stopRead) && (!stahpLoop)); // When we get close enough to the wall, stop.
      faulhaber.changeSpeed(activeBrakeSpeed);
      faulhaber.layInSpeed();
      faulhaber.switchDirection(BACKWARD);
      w8(activeBrakeTime);
      faulhaber.frictionStop();
      w8(stopDelay);
      if (stahpLoop) {
        stahpLoop = 0;
        Serial1.println("Check.");
        break;
      }   
      sensorL = analogRead(A0);
      sensorR = analogRead(A2);
#if TELEMETRY
      Serial1.print("Left ENC: ");
      Serial1.println(lMotorEnc);
      Serial1.print("Right Enc: ");
      Serial1.println(rMotorEnc);      
      Serial1.print("Left Sensor: ");
      Serial1.println(sensorL);
      Serial1.print("Right Sensor: ");
      Serial1.println(sensorR);
#endif
      if (sensorL > turnThresholdL && sensorR > turnThresholdR) {
#if TELEMETRY
        Serial1.println("R turn!");
#endif
        eState_t = eTurnR; // After this, we want to be turning 180 degrees
      } else if (sensorR > turnThresholdR) {
#if TELEMETRY
        Serial1.println("Turning Right.");
#endif
        eState_t = eTurnR;
      } else if (sensorL > turnThresholdL) {
#if TELEMETRY
        Serial1.println("Turning Left.");
#endif
        eState_t = eTurnL;
      } else {
        eState_t = eTurnU;
#if TELEMETRY
         Serial1.println("U turn!");
#endif
      }
    break;
    case eTurnU:
      digitalWrite(led, LOW); // Turn the LED off so that we know that it's trying to go backwards
      faulhaber.frictionStop();
      faulhaber.turnAround(0); // make the motor control pins go backward
      faulhaber.changeSpeed(turnSpeed);
      faulhaber.layInSpeed();
      w8(uDelay);
      faulhaber.turnAround(1);
      faulhaber.changeSpeed(activeTurnBrakeSpeed);
      faulhaber.layInSpeed();
      w8(activeTurnBrakeTime);
      eState_t = eForward; // loop to go forward again
      enc.forceMark();
    break;
    case eTurnL:
      digitalWrite(led, LOW);
      faulhaber.frictionStop();
      faulhaber.turnAround(0);
      faulhaber.changeSpeed(turnSpeed);
      faulhaber.layInSpeed();
      w8(tDelay);
      faulhaber.turnAround(1);
      faulhaber.changeSpeed(activeTurnBrakeSpeed);
      faulhaber.layInSpeed();
      w8(activeTurnBrakeTime);
      eState_t = eForward;
      enc.forceMark();
    break;
    case eTurnR:
      digitalWrite(led, LOW);
      faulhaber.frictionStop();
      faulhaber.turnAround(1);
      faulhaber.changeSpeed(turnSpeed);
      faulhaber.layInSpeed();
      w8(tDelay);
      faulhaber.turnAround(0);
      faulhaber.changeSpeed(activeTurnBrakeSpeed);
      faulhaber.layInSpeed();
      w8(activeTurnBrakeTime);
      eState_t = eForward;
      enc.forceMark();
    break;
    default:
      eState_t = eForward;
    break;
  }
}

void lMotorInc() {
  enc.lMotorInc();
}

void rMotorInc() {
  enc.rMotorInc();
}
